# MSA-STUDY BY 코드프레소

## BOOK
스프링 마이크로서비스 코딩 공작소




### 220621
3장 config 4장 eureka 실습 파일 초안 버전 업데이트


### 220621
3장 config 4장 eureka 실습 파일 정리
5장 hystrix 5장 zuul 실습 파일 정리

### 220723 
6장 7장 8장 9장까지 msa 스터디 마무리


# 스터디 내용

# 2주차

## 설정 외부화 패턴

### 이론

Cofing Server를 통해 여러 설정들을 외부에서 관리함

서비스 인스턴스가 시작하는 시점에만 Config Server에서 정보 조회 ( 인스턴스 운영중에 Config server의 장애가 발생해도 OK )

### 구현

<파일 기반>

- ConfigServer 생성
- ConfigServer  pom.xml에 Configserver 의존성 추가
- Application.java에 EnableConfigServer 어노테이션 추가
- apllciation.yml 파일에 cloud-config 관련 설정 추가
- src/main/resources 하위에 설정할 어플리케이션 이름의 폴더 추가
- 생성된 폴더에 yml 파일 추가
- 설정정보 이동
- 어플레케이션 pom.xml에 config-client, starter-config 의존성 추가
- src/main/resources 하위에 bootstrap.yml 추가 후 cloud: config 설정 추가

<git 기반>

- apllciation.yml 파일에 cloud-config 관련 설정 추가했던 걸 git으로 수정

## 서비스 디스커버리 패턴

### 이론

넷플릭스 유레카로부터 파생

대규모 분산 환경에서 서비스 디스커버리를 지원

서비스들이 Eureka Client가 되고 실행 시점에 Eureka Server에 자기 자신의 정보를 등록

서비스가 생성되면 자신의 정보를 에이전트에 등록하며 클라이언트들이 에이전트를 이용해 서비스 위치 검색이 가능하고 에이전트들끼리 클러스팅 하여 각자의 정보를 다른 서비스에 공유!

특징

1. 고가용성 : 서비스의 정보를 여러개의 노드가 공유
2. 피어 투 피어 : 모든 노드들이 서비스들의 상태를 공유
3. 장애 내성 : 에이전트는 인스턴스의 비정상 상태를 감지하고 제거함 → 사람 개입 없이
4. 회복성 : 클라이언트는 서비스의 정보를 로컬에 캐스(Ribbon)
5. 부하 분산 : 클라이언트의 요청을 후방 서비스들에게 분산해서 전달

Ribbon!

주기적으로 에이전트에 질의하여 에이전트로부터 받은 정보를 로컬에 캐싱→ 캐싱한 정보로 서비스를 호출

client-side load balancing 기능 수행

### 구현

- EurekaServer 생성
- pom.xml에 netflix-eureka-server 의존성 추가
- Application.java에 @EnableEurekaServer 어노테이션 추가
- application.yml에 eureka: client: 설정 정보 추가
- 서비스로 돌아가서 pom.xml에 netflix-eureka-clinet 추가
- application.yml 에 eureka: client 관련 설정 추가
- localhost:유레카서버포트/eureka/apps에서 확인

서비스 디스커버리를 이용하면 타 서비스 인스턴스의 물리적인 위치를 몰라도 됨!

Ribbon이 활성화된 RestTemplate 방법으로 적용

- 서비스 Application.java에 @LoadBalanced 어노테이션 추가
- restTemplate를 쓰는 곳에 가서 eureka에 등록된 서비스 이름으로 변경
- ex) localhost:8080→서비스이름




# 3주차

들어가기 전

넷플릭스 프로젝트들이 다 바뀌고 있다

Netflix Hystrix → Spring Cloud Circuit Breaker

Netflix Zuul → Spring Clod Gateway

기능 자체는 다 비슷하다

Spring Cloud Circuit Breaker 에는 리트라이 기능 정도 추가되었다

## 회로 차단기 패턴

### 이론

분산 시스템의 장애 

장애가 생긴 애를 지속적으로호출하지 않게 하자~가 목표!

장애가 발생한 서비스를 계속 호출하면 클라이언트도 망가질 수도 있다 

전체의 장애보다는 일부의 장애만 나는게 낫다

ex) 네이버 블로그는 안되더라도 네이버 카페는 될 수 있도록 

Circuit Breaker

원격 서비스에 대한 호출 정보를 집계하여 비정상 서비스를 반복적으로 호출하지 않도록 제어 → 특정 원격 자원에 대한 호출이 정해진만큼 실패할 경우 해당 원격 자원에 대해 호출하지 않도록 차단

fallback 

Circuit 차단 시 예외를 발생 시키는 대신 대체 행동을 정의

다른 데이터베이스를 호출하거나 향후 처리를 위해 Retry queue에 넣거나 하드 코딩된 결과를 응답하도록 설계

SG 회사 다닐 때 이런 패턴을 적용한 적이 있는데 추천 시스템 → 딥러닝 모델을 만들면 다른 팀에 서빙하는 일 커뮤니티 글 추천 

UI → 커뮤니티 → 추천서비스 → 딥러닝모듈 순서로 호출, 딥러닝이 굉장히 느렸음

그래서 추천시스템에서 hystrix를 붙이기로 함 5초 이상 걸리면 fallback 패턴을 둬서

개인화 된 맞춤 컨텐츠가 아닌 인기 컨텐츠를 추천할 수 있는 시스템을 붙임 

bulkhead 

원격 자원에 대한 호출을 자원 별 스레드 풀로 격리하여 관리

### 구현

- msa구성중인 프로젝트에 netflix-hystrix 의존성 추가
- Application.java에 어노테이션 추가(EnableHystrix)
- Circuit Breaker를 적용할 함수에 어노테이션 추가(HystrixCommand)
- yml 파일에 타임아웃, 실패 확률, 최소 호출 수 등을 Setting
- fallback method 구현(기존 method와 리턴타입, 파라미터가 동일해야함)

---

---

---

## 서비스 게이트웨이 패턴

### 이론

MSA의 각 서비스마다 동일하게 적용되야 하는 기능들(보안, 로깅, 분산 추적) 등이 존재하기 때문에 공통 라이브러리를 만들어서 사용하면 좋지 않을까? 하는 생각으로 나온 개념

즉! 필터단의 역활들을 각자 만들지 말고 하나의 곳으로 모여서 하자! 중앙화하자 → 다시 단점이 된다!  공통 라이브러리가 수정되면 모든 서비스들이 영향이 맞기 때문

Cross Cutting Concerns를 서비스들과 독립적으로 구성

한 정책 지점을 만들어 모든 호출이 해당 지점을 통한 후 각 서비스로 라우팅되도록하는 역할

### 구현

- 신규 springboot 프로젝트 구성
- Zuul 메이븐 의존성 추가 (netflix-zuul, eureka-client)
- [Application.java](http://Application.java) 에 Zuul 어노테이션 설정
- Eureka와 연동
- 라우팅 설정


## 4주차

# 7장 마이크로서비스 보안

마이크로서비스 보안 관리의 어려움

- 모노리틱 시스템에서는 단일 언어, 단일 프레임워크, 단일 데이터베이스를 활용하기 때문에 중앙화된 단일 보안 정책 적용이 가능
- 마이크로서비스는 기술이 다양하고 분산되어 중앙 집중적인 통일성 잇는 보안 정책 적용 어려움
    - API의 분산
    - 언어와 프레임워크의 다양성
    - 데이터베이스의 다양성과 분산
    - 네트워크를 활용한 호출 증가
    

마이크로서비스 보안 원칙

- 네트워크 보안
    - 모든 통신은 HTTPS를 활용한다
    - IP Port의 외부 공개는 최소한 or 하지 않는다(gateway 활용)
- API 인증과 인가
    - 모든 서비스의 API들은 인증된 사용자들만 사용가능
    - API 별로 권한 관리를 해야 함
- 데이터 보안
    - 각 서비스들의 데이터베이스에 대한 접근은 그 서비스 애플리케이션에서만 가능
    - 다른 서비스의 데이터베이스를 직접 접근 X
- 코드 레벨 보안
    - 각 언어별로 Secure 코등 룰을 정의
    - 개발 환경에서의 매 빌드 별 코딩 룰 위반을 탐지하고 관리한다
    

API 인증 및 인가

- 인증
    - who you are 사용자가 누군지 확인하는 절차
    - 건물에 사원증 찍고 들어가기
- 인가
    - what you do? 사용자에 권한을 부여하고 자원 요청 시 가능한 권환을 확인하는 절차
    - 각 층의 문을 열 수 있는 지문찍고 들어가기
- 쿠키/세션의 활용
    - 사용자 인증, 인가 정본ㄴ 세션 정보에 저장
    - 쿠키는 세션을 조회할 수 있는 key 정보를 저장
    - 세션 저장소로는 redis memcached를 활용
    - 서비스 간의 공유 DB를 사용해야 한다는 단점 존재
    
- OAuth2.0
    - 자원과 인증/인가를 분리하는 방식의 표준 프로토콜
    - 자원 : 클라이언트가 접근을 원하는 API
    - 인증 및 인가를 담당하는 서비스를 별도로 구축/운영
    - Resource owner 자원소유자 : resource server의 계정을 소유하고 있는 사용자를 의미
    - Client : API 서비스를 사용하는 제 3이 서비스
    - Resource Server 권한 서버 : 권환을 관리해주는 서버 토큰 발급 역활
    - Resource server : OAuth2 서비스를 제공하고 자원을 관리하는 서버
    - Access Token 발급받은 인증 토큰, Resource server에 전달하고 서비스를 제공 받을 수 있음
    

# 8장 이벤트 기반 cloud stream

가장 큰 이유 : 서비스 간의 결합도를 낮추기 위해

Orchestration vs Choreography

코레오 특정 이벤트를 단순 발행, 이벤트를 구독하는 서비스들이 각자 적절한 조치를 취함, 구조가 명시적이지 않아 모니터링 및 추적에 어려움 존재

오케스트레이션 : 중앙에서 전체 flow를 관리, 

추가적인 미들웨어, 이벤트 추적, 다른 여러 비용이 들 수 있는데

이를 위해서 다른 여러 툴들이 나오기 있기 때문에 ex 다음주에 할 분산추적 같은 경우

완화 가능하다고 보고 있다

장점

느슨한 결합 : 내 서비스를 사용하는 곳을 알지 못한다 내 서비스 R&R 감소

내구성 : 서비스 장애에 대한 내구도가 높다. 발신|수신 측이 죽어도 서로 영향을 주지 않는다

(빠른 시간내에 회복이 보장된다면)

확장성 : 결합도가 낮으므로 기존 서비스의 수평 확장이 편리하다

유연성 언제든 자유롭게 신규 서비스 추가 가능

단점

의미론 : 메시지 순서에 대한 고려 : ex 순서를 보장해야하는 event 인지 아닌지

가시성 : 비동기적 특성 디버깅이 중요해짐

메시지 코레오그래피 :  비지니스 로직을 추론하는 것이 어려워짐

~실습발표



## 5주차

# 9장 ****슬루스와 집킨****

Spring Cloud Sleuth는 각 서비스간의 트랜잭션을 연결해주는 상관관계ID를 자동으로 주입

어플리케이션 이름 ; Trace id ; span id ; 집킨 전송 여부(true or false)

1. 어플리케이션 이름**:** 로그를 출력하는 어플리케이션 이름 
2. trace id: 전체 트랜잭션에서 고유한 숫자
3. span id: 전체 트랜잭션의 일부를 나타내는 고유 id 트랜잭션을 시각화하는데 유용
4. 집킨 전송 여부(true or false)

슬루스는 로그 수집용 기술 도구나 추적 도구와 결합되어 사용된다

책에서는 페이퍼트레일(여러 마이크로서비스의 로그를 실시간으로 질의 가능한 데이터베이스로 수집하는 클라우드 기반 로깅 플랫폼)을 이용해서 로그를 수집하는 실습을 진행

 

실습 : 

집킨 : 스프링 클라우드 슬루스가 생성한 데이터를 사용해 단일 트랜잭션에 연관된 서비스의 호출 흐름을 시각화




